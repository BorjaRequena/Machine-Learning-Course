# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/lib_nbs/01_losses.ipynb.

# %% auto 0
__all__ = ['MSE', 'grad_MSE_lr', 'grad_MSE_pr', 'BCE']

# %% ../nbs/lib_nbs/01_losses.ipynb 2
import numpy as np
from .data_gen import curve

# %% ../nbs/lib_nbs/01_losses.ipynb 4
def MSE(x:np.ndarray, # x data of N elements
        y:np.ndarray, # y data of N elements
        fun:callable, # function $y=f(x)$
        params=None, # Parameters of the function in the form of a dictionary
       )->float:
    '''Given the data $x$ and $y$, this function computes the mean square error between $y$ and $y'=f(x)$'''
    yp = fun(x) if params is None else fun(x,**params)
    MSE = np.mean((y-yp)**2)
    return MSE

# %% ../nbs/lib_nbs/01_losses.ipynb 6
def grad_MSE_lr(x:np.ndarray, # x data of N elements
                y:np.ndarray, # y data of N elements
                params: dict, # Parameters of the function
            )-> np.ndarray: # gradients
    '''Computes the gradient of the mean square error loss function with respect to $a$ and $b$ and returns np.array([$\partial_a$ MSE,$\partial_b$ MSE])'''
    a, b = params['a'], params['b']
    yp = a*x+b
    ga, gb = np.mean(2*x*(yp-y)), np.mean(2*(yp-y))
    return np.array([ga,gb])

# %% ../nbs/lib_nbs/01_losses.ipynb 7
def grad_MSE_pr(x:np.ndarray, # x data of N elements
                y:np.ndarray, # y data of N elements
                params: dict, # parameters of the function
            )-> np.ndarray: # gradients
    '''Computes the gradient of the mean square error loss function with respect to $a$ and $b$ and returns np.array([$\partial_a$ MSE,$\partial_b$ MSE])'''
    coeffs = params['coeffs']
    yp = curve(x, **params)
    ll = -2*(y-yp)
    g = []
    for i in range(len(coeffs)):
        g.append(np.mean(ll*x**i))
    return [np.array(g)]

# %% ../nbs/lib_nbs/01_losses.ipynb 8
def BCE(x:np.ndarray, # x data of N elements
        y:np.ndarray, # y data of N elements
        fun:callable, # function $y=f(x)$
        params: dict # Parameters of the function
       )->float:
    '''Given the data $x$ and $y$, this function computes the mean binary cross entropy $y$ and $y'=f(x)$'''
    yp = fun(x) if params is None else fun(x,**params)
    l = y*np.log(yp) + (1-y)*np.log(1-yp)
    return -np.mean(l)
