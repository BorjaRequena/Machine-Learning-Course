"""This module generates different types of data"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/lib_nbs/00_data_gen.ipynb.

# %% auto 0
__all__ = ['line', 'noisy_line', 'curve', 'noisy_curve']

# %% ../nbs/lib_nbs/00_data_gen.ipynb 2
import numpy as np

# %% ../nbs/lib_nbs/00_data_gen.ipynb 3
def line(x:np.ndarray,
         a=1.0,#Slope
         b=0.5,#Intercept
         interval=[-10.,10.],#Interval for x.
         noise=[0,1E-5],# Noise [$\mu$,$\sigma$] with mean $\mu$ and standard deviation $\sigma$
         nsamples=100# Number of samples
        )-> np.ndarray: # the array $y=ax+b$
    '''Create a dataset of nsamples in the interval following the linear regression $y=a x+b$.'''
    return a*x+b

# %% ../nbs/lib_nbs/00_data_gen.ipynb 4
def noisy_line(a=1.0,#Slope
               b=0.5,#Intercept
               interval=[-10.,10.],#Interval for x.
               noise=[0,1E-5],# Noise [$\mu$,$\sigma$] with mean $\mu$ and standard deviation $\sigma$
               nsamples=100# Number of samples
              ):
    '''
    Create a dataset of nsamples in the interval following the linear regression $y=a x+b$ and adds a gaussian noise on y.
    
    Returns
    -------
    tuple
        - a random x vector in the interval of size nsamples
        - the noisy vector following $y= ax+b$
    '''
    x = np.random.uniform(low=interval[0], high=interval[1], size=nsamples)
    mu, sigma = noise
    vnoise = np.random.normal(loc=mu, scale=sigma, size=nsamples)
    return x, a*x+b+vnoise

# %% ../nbs/lib_nbs/00_data_gen.ipynb 5
def curve(x, # dataset to be imputed
          coeffs, # array of the weights of the polynomial of degree d-1, where d is the size of the array.
         )->np.ndarray: #the vector $y=w \cdot x$
    '''Create a vector following the polynomial curve $y=w^Tx$, where $x=(x^0...x^d)$ and  $x=(w^0...w^d)$.'''
    ncoeff = len(coeffs)
    ex = np.arange(ncoeff)
    y=0
    for i in range(ncoeff): 
        y = y+ coeffs[i]* x**ex[i]
    return y

# %% ../nbs/lib_nbs/00_data_gen.ipynb 6
def noisy_curve(coeffs, # array of the weights of the polynomial of degree d-1, where d is the size of the array.
                x= None, # dataset to be imputed. if x is `None`, then the dataset is constructed with nsamples from a uniform distribution
                interval=[-2,2], # interval for the sampling of x
                noise=None, # tuple contining $\mu$ and $\sigma$. If  noise is `None`, then there is no noise 
                nsamples=100 # number of samples for x
               ):
    '''Create a dataset of nsamples in the interval following the polynomial curve $y=w^Tx$, where $x=(x^0...x^d)$ and  $x=(w^0...w^d)$ and adds a gaussian noise on y.
    
    Returns
    -------
    tuple
        - a random x vector in the interval of size nsamples
        - the noisy vector following $y=w \cdot x$
    '''
    if x is None: x = np.random.uniform(low=interval[0], high=interval[1], size=nsamples)  
    if noise is None: 
        vnoise = 0 
    else:
        mu, sigma = noise
        vnoise = np.random.normal(loc=mu, scale=sigma, size=nsamples) 
    ncoeff = len(coeffs)
    ex = np.arange(ncoeff)
    y = 0
    for i in range(ncoeff): 
        y = y+ coeffs[i]* x**ex[i]
    return x, y+vnoise
